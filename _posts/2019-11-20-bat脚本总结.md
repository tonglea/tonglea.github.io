# 1常用基本命令

## 1.1 @ 

它的作用是让执行窗口中不显示它后面这一行的命令本身

## 1.2 echo 

它其实是一个开关命令，就是说它只有两种状态：打开和关闭。于是就有了echo on 和echo off两个命令了。直接执行echo命令将显示当前echo命令状态（off或on）执行echo off将关闭回显

## 1.3 :: 

它是注释命令，在批处理脚本中和rem命令等效。

## 1.4 pause

它的作用，是让当前程序进程暂停一下，并显示一行信息：请按任意键继续. . .。

## 1.5 :和goto 

goto是个跳转命令，: 是一个标签。当程序运行到goto时，将自动跳转到:定义的部分去执行了
如：

    ……
    goto end
    ……
    :end 

## 1.6 %

这个百分号严格来说是算不上命令的，它只是批处理中的参数而已，少了它批处理的功能就减少了51%了

## 1.7 if

if命令是一个表示判断的命令，根据得出的每一个结果

### 输入判断

如：

	if "%1"=="" goto usage 
	if not "%1"=="" goto usage

### 存在判断

如：

    if exist C:\Progra~1\Tencent\AD\*.gif del C:\Progra~1\Tencent\AD\*.gif 
    if not exist C:\Progra~1\Tencent\AD\*.gif exit

### 结果判断

如：

    masm %1.asm
    if errorlevel 1 pause & edit %1.asm
    link %1.obj 

`“if not errorlevel 1”`和`“if errorlevel 0”`的效果是等效的

一般上一条命令的执行结果errorlevel返回的值只有两个，"成功"用0 表示 "失败"用 1 表示，实际上，errorlevel 返回值可以在0~255 之间

全部的比较参数如下：

`EQU` - 等于
`NEQ` - 不等于
`LSS` - 小于
`LEQ` - 小于或等于
`GTR` - 大于
`GEQ` - 大于或等于

## 1.8 call 

call命令用来从一个批处理脚本中调用另一个批处理脚本

**脚本调用可以灵活运用，循环运用、重复运用**

**脚本调用可以使用参数**
call脚本带参数情况：

    start.bat：
    ……
    CALL 10.BAT 0
    ……
    
    10.bat：
    ……
    ECHO %IPA%.%1 >HFIND.TMP
    ……
    CALL ipc.bat IPCFind.txt
    
    ipc.bat：
    for /f "tokens=1,2,3 delims= " %%i in (%1) do call HACK.bat %%i %%j %%k 

把10.bat里的参数%1用0代替。在start.bat中，ipc.bat后面跟了参数ipcfind.txt（一个文件，也可以做参数），执行时的效果，就是用ipc.bat中的每一行的三个变量，对应代换ipc.bat中的%%i、%%j和%%k。

## 1.9 find 

这是一个搜索命令，用来在文件中搜索特定字符串

    @echo off
    netstat -a -n > a.txt
    type a.txt | find "7626" && echo "Congratulations! You have infected GLACIER!"
    del a.txt
    pause & exit 

先用netstat命令检查是否有冰河默认的端口7626在活动，并把结果保存到a.txt中。然后使用type命令列出a.txt中的内容，再在列出的内容中搜索字符串“7626” ，发现有的话则提示中了冰河，否则退出。

如果不使用type命令列出a.txt中的内容，而是直接使用find命令在a.txt中找“7626”，就必须得给出这个a.txt的绝对路径

## 1.10 for

FOR 参数 %%变量名 IN (相关文件或命令) DO 执行的命令

### 参数

FOR有4个参数 /d   /l   /r   /f   

他们的作用我在下面用例子解释

%%变量名 :这个变量名可以是小写a-z或者大写A-Z,他们区分大小写,FOR会把每个读取到的值给他;

IN:命令的格式,照写就是了;

(相关文件或命令) :FOR要把什么东西读取然后赋值给变量,看下面的例子
do:命令的格式,照写就是了!

执行的命令:对每个变量的值要执行什么操作就写在这.

可以在CMD输入for /?看系统提供的帮助!对照一下

`/d`  仅为目录

	for /d %%i in (*) do @echo %%i 

把他保存放在C盘根目录执行,就会把C盘目录下的全部目录名字打印出来

`/r` 递归

	for /r c: %%i in (*.exe) do @echo %%i 

把这个BAT保存到D盘随便哪里然后执行,我会就会看到,他把C盘根目录,和每个目录的子目录下面全部的EXE文件都列出来了,这里的c:就是目录了。

`/L` 迭代数值范围

系统帮助的格式:for /L %% Variable in (Start#,Step#,End#) do Command

	for /l %%i in (1,1,5) do @echo %%i 

他会打印从1 2 3 4 5 这样5个数字

	for /l %%i in (1,1,5) do start cmd

执行后是不是吓了一跳,怎么多了5个CMD窗口

`/f`

含有/F的for有很大的用处，在批处理中使用的最多

    FOR /F ["options"] %%i IN (file) DO command
    FOR /F ["options"] %%i IN ("string") DO command
    FOR /F ["options"] %%i IN (command) DO command

file 代表一个或多个文件

string 代表字符串

command 代表命令

假如文件a.txt中有如下内容：

	第1行第1列第1行第2列 第1行第3列
	第2行第1列 第2行第2列 第2行第3列
	第3行第1列 第3行第2列 第3行第3列

你想显示a.txt中的内容，会用什么命令呢？当然是type，type a.txt
	
	for /f %%i in (a.txt) do echo %%i

还是先从括号执行，因为含有参数/f,所以for会先打开a.txt，然后读出a.txt里面的所有内容，把它作为一个集合，并且以每一行作为一个元素，所以会产生这样的集合，

{"第1行第1列 第1行第2列 第1行第3列"， //第一个元素
"第2行第1列 第2行第2列 第2行第3列"， //第二个元素
"第3行第1列 第3行第2列 第3行第3列"}   //第三个元素

集合中只有3个元素，同样用%%i依次代替每个元素，然后执行do后面的命令。

具体过程：

用%%i代替"第1行第1列 第1行第2列 第1行第3列"，执行do后面的echo %%i，显示"第1行第1列 第1行第2列 第1行第3列"，
用%%i代替"第2行第1列 第2行第2列 第2行第3列"，执行echo %%i，显示"第2行第1列 第2行第2列 第2行第3列"，
依次，直到每个元素都代替完为止。

### delims

delims 用来告诉for每一行应该拿什么作为分隔符，默认的分隔符是空格和tab键	

	for /f "delims= " %%i in (a.txt) do echo %%i

显示的结果是：

第1行第1列
第2行第1列
第3行第1列

为什么是这样的呢。因为这里有了delims这个参数，=后面有一个空格，意思是再将每个元素以空格分割，默认是只取分割之后的第一个元素。
执行过程是：

将第一个元素"第1行第1列 第1行第2列 第1行第3列"分成三个元素："第1行第1列" "第1行第2列" "第1行第3列"，它默认只取第一个，即"第1行第1列"，然后执行do后面的命令，依次类推。

但是这样还是有局限的，如果我们想要每一行的第二列元素，那又如何呢？

### tokens

它的作用就是当你通过delims将每一行分为更小的元素时，由它来控制要取哪一个或哪几个。

还是上面的例子，执行如下命令：

	for /f "tokens=2 delims= " %%i in (a.txt) do echo %%i

执行结果：

第1行第2列
第2行第2列
第3行第2列

如果要显示第三列，那就换成tokens=3。

同时tokens支持通配符*，以及限定范围。

如果要显示第二列和第三列，则换成tokens=2,3或tokens=2-3,如果还有更多的则为：tokens=2-10之类的。

此时的命令为：

	for /f "tokens=2,3 delims= " %%i in (a.txt) do echo %%i %%j

怎么多出一个%%j？

这是因为你的tokens后面要取每一行的两列，用%%i来替换第二列，用%%j来替换第三列。

并且必须是按照英文字母顺序排列的，%%j不能换成%%k，因为i后面是j
执行结果为：

第1行第2列第1行第3列
第2行第2列 第2行第3列
第3行第2列 第3行第3列

对以通配符*，就是把这一行全部或者这一行的剩余部分当作一个元素了。
比如：

	for /f "tokens=* delims= " %%i in (a.txt) do echo %%i

执行结果为：

第1行第1列第1行第2列 第1行第3列
第2行第1列 第2行第2列 第2行第3列
第3行第1列 第3行第2列 第3行第3列

其实就跟`for /f %%i in (a.txt) do echo %%i`的执行结果是一样的。
再如：	

	for /f "tokens=2,* delims= " %%i in (a.txt) do echo %%i %%j

执行结果为：

第1行第2列第1行第3列
第2行第2列 第2行第3列
第3行第2列 第3行第3列
用%%i代替第二列，用%%j代替剩余的所有


# 2 Bat脚本压缩与解压缩

## 2.1压缩

WinRAR.exe a -o+ -r -s -m1 -df ..\..\..\bak\backup.rar ..\base_db.sql

命令m 表示移动（压缩后，删除源文件）
命令a 表示添加压缩
命令s 表示创建自解压文件

实用开关：

`-r` 含子文件夹
`-ai` 忽略文件属性
`-cl` 文件名小写
`-cu` 文件名大写
`-ed` 忽略空文件夹
`-ep` 忽略路径信息
`-ep1` 表示忽略被压缩的根文件夹
`-ep2` 包含最完整路径信息（除驱动器）
`-df` 表示压缩后删除源文件
`-dr` 删除源文件到回收站
`-or` 自动重命名同名文件

## 2.2解压缩

`WinRAR x` 压缩包路径 解压缩到目标文件夹的路径

解压缩保留路径

`WinRAR e` 压缩包路径 解压缩到目标文件夹的路径

解压缩忽略路径

忽略路径的意思，就是解压缩时，压缩包原来里面有文件夹的，解压缩之后，只能得到所有文件，而文件夹没了。

	WinRAR.exe e backup.rar

在压缩和解压缩的过程中WinRAR.exe应该是压缩软件的全路径,我并不知道服务器的WinRAR.exe的全路径,而且不同的服务器,WinRAR.exe的全路劲可能不一样。为了保证路径不会错误,可以复制一个WinRAR.exe到对应目录,压缩时,用复制的WinRAR.exe就不会错误。

# 3 知识小结

## 3.1 Call与start

### 调用范围不同

call 主要用来进行批处理的内部调用，如call :pend 和一些dos命令的调用如call set test=2，但也可以调用其他可执行文件，而start则不能进行内部调用，但其可以执行基本上所有的外部 程序，还可以执行shell，如打开文件夹start "" "%WINDIR%"，安装网络打印机start "" "\\IP\Printer"等 等。

### 调用方式不同

call 是严格意义上而言的调用，在call另一个批处理时是在同一窗体进程里执行，而start则是执行，所以在执行另外一个批处理时是在不同的窗体进程里进行，也就是说在新开启的进程里执行，虽然start可以加入b参数，但其结果却完全不同。

如我们使用call set test=2 和 start /b set test=2 看似执行的结果相同，但是我们发现后者有两个进程，而且在窗体里要执行两次exit才能退出，所以当我们使用start来执行一个批处理后最好在被调用的 批处理中也加一个exit，否则无法退出被调用的批处理的dos窗体，但是使用call调用时如果在被调用的批处理中存在exit则会直接结束原始和被调 用的批处理程序，这是一个非常严重的问题。建议在被调用的批处理中使用goto :eof来取代exit。

### 调用结果不同

call 调用不仅可以把参数或变量传给被调用的批处理，而且被调用的批处理也可以设置参数或变量以便回传，而start只能把参数或变量传给被调用的批处理，却不 能回传参数或变量，这一点实际上是第二点的延伸。另外，我们还必须注意一点：使用call调用其他批处理时，在被调用的批处理中若我们使用goto命令的 时候，建议要使用与原批处理中不同的标签名来跳转，否则可能会跳转到原批处理中而不能保证完整的执行被调用批处理中的所有语句。

对于start，概况二句话：“不同进程不能传值”，“相同进程单向传值，老子传儿子，非儿子传老子”。
　　对于call，“同一进程，变量互通”。call的最大特点是可以调用本批内的标签，继承父批的环境变量，返回时带着子批的环境变量，start不能。

## 3.2errorlevel

Errorlevel表示上一句执行状态,成功返回0,失败返回1

`if %errorlevel%==0`表示执行成功

`if %errorlevel%==1`表示执行失败

一般用与执行sql语句之后,bat脚本执行sql语句后,如果失败了,有时没有显示失败,让人误以为成功了,会导致后面错误,加上errorlevel判断后,可以很好的进行处理

## 3.3提示用户输入

`set /p` 提示用户输入
`set /a` 执行数学计算

比如 set /p a=等待POP输入： ，然后窗口提示“等待POP输入：” ，输入完后 按回车

    @echo off
    set /p b=输入一个数字：
    echo %b%
    set /a a=2*%b%
    echo %b%+%b%=%a%
    pause>nul

Set /p 主要用于用户输入,在sql语句中,有时需要用户输入IP,密码,端口号等,在实际工作中很常见
